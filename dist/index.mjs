import{combine as e,createStore as r,createEvent as i,sample as t,merge as o}from"effector";import{useUnit as n,useVModel as s}from"effector-vue/composition";const l={store:function({init:e,domain:i,existing:t},o){return t||(i?i.createStore(e,o):r(e,o))},event:function({domain:e,existing:r}){return r||(e?e.createEvent():i())}};function u(r,i,t){var o,n,s,u,a,d,c,v,f,m,h,$;const g="function"==typeof i.init?i.init():i.init,p=l.store({domain:t,existing:null===(o=i.units)||void 0===o?void 0:o.$value,init:g},{sid:`${r}-$value`}),x=l.store({domain:t,existing:null===(n=i.units)||void 0===n?void 0:n.$errors,init:[]},{sid:`${r}-$errors`}),V=x.map((e=>e[0]?e[0]:null)),E=l.store({domain:t,existing:null===(s=i.units)||void 0===s?void 0:s.$initValue,init:g},{sid:`${r}-$initValue`}),y=l.store({domain:t,existing:null===(u=i.units)||void 0===u?void 0:u.$isTouched,init:!1},{sid:`${r}-$touched`}),T=e(p,E,((e,r)=>e!==r)),b=l.event({domain:t,existing:null===(a=i.units)||void 0===a?void 0:a.onChange}),F=l.event({domain:t,existing:null===(d=i.units)||void 0===d?void 0:d.onBlur}),k=l.event({domain:t,existing:null===(c=i.units)||void 0===c?void 0:c.changed}),O=l.event({domain:t,existing:null===(v=i.units)||void 0===v?void 0:v.addError}),S=l.event({domain:t,existing:null===(f=i.units)||void 0===f?void 0:f.validate}),w=l.event({domain:t,existing:null===(m=i.units)||void 0===m?void 0:m.resetErrors}),D=l.event({domain:t,existing:null===(h=i.units)||void 0===h?void 0:h.resetValue}),B=l.event({domain:t,existing:null===($=i.units)||void 0===$?void 0:$.reset}),C=V.map((e=>null===e)),P=V.map((e=>(null==e?void 0:e.errorText)||"")),I=e({value:p,errors:x,firstError:V,isValid:C,isDirty:T,isTouched:y}),j={value:p,initValue:E,isValid:C,isDirty:T,touched:y,errors:x,firstError:V,errorText:P,onChange:b,onBlur:F,addError:O,validate:S,reset:B,resetErrors:w,resetValue:D};return{changed:k,name:r,$initValue:E,$value:p,$errors:x,$firstError:V,$errorText:P,$isValid:C,$isDirty:T,$isTouched:y,$touched:y,$field:I,onChange:b,onBlur:F,addError:O,validate:S,set:b,reset:B,resetErrors:w,resetValue:D,filter:i.filter,"@@unitShape":()=>j}}function a(i){const{form:n,field:s,fieldConfig:l}=i,u=l.rules||[],a=n.validateOn||["submit"],d=l.validateOn||[],{$value:c,$errors:v,onBlur:f,changed:m,addError:h,validate:$,resetErrors:g,resetValue:p,reset:x}=s,V="function"==typeof u?r([],{sid:`${s.name}-$rulesSources`}):e(u.map((({source:e},i)=>{const t=`${s.name}-$rulesSources-${i}`;return e||r(null,{sid:t})}))),E=function(e){return(r,i,t)=>{const o=[],n="function"==typeof e?e(r,i):e;for(let e=0;e<n.length;e++){const s=n[e],l=t?t[e]:null,u=s.validator(r,i,l);"boolean"!=typeof u||u||o.push({rule:s.name,errorText:s.errorText,value:r}),"object"!=typeof u||u.isValid||o.push({rule:s.name,errorText:u.errorText,value:r})}return o}}(u),y=[...a,...d],T=[];if(y.includes("submit")){const r=t({source:e({fieldValue:c,form:n.$values,rulesSources:V}),clock:n.submit});T.push(r)}y.includes("blur")&&T.push(t({source:e({fieldValue:c,form:n.$values,rulesSources:V}),clock:f})),y.includes("change")&&T.push(t({source:e({fieldValue:c,form:n.$values,rulesSources:V}),clock:o([m,p,n.resetValues])})),T.push(t({source:e({fieldValue:c,form:n.$values,rulesSources:V}),clock:$})),T.push(t({source:e({fieldValue:c,form:n.$values,rulesSources:V}),clock:n.validate}));const b=t({source:c,clock:h,fn:(e,{rule:r,errorText:i})=>({rule:r,value:e,errorText:i})}),F=t({source:c,clock:n.addErrors,fn:(e,r)=>({value:e,newErrors:r})});v.on(T,((e,{form:r,fieldValue:i,rulesSources:t})=>E(i,r,t))).on(b,((e,r)=>[r,...e])).on(F,((e,{value:r,newErrors:i})=>{const t=[];for(const e of i)e.field===s.name&&t.push({value:r,rule:e.rule,errorText:e.errorText});return[...t,...e]})).reset(g,n.reset,x,n.resetErrors),y.includes("change")||v.reset(m)}function d({field:e,form:r}){const{$value:i,$initValue:n,$touched:s,onChange:l,changed:u,name:a,reset:d,resetValue:c,filter:v}=e,{setForm:f,setInitialForm:m,resetForm:h,resetTouched:$,resetValues:g}=r,p=t({source:n,clock:o([d,c,g,h])});s.on(u,(()=>!0)).reset(d,h,$),t(v?{source:l,filter:v,target:u}:{source:l,filter:()=>!0,target:u}),n.on(m,((e,r)=>r.hasOwnProperty(a)?r[a]:e)),i.on(u,((e,r)=>r)).on([f,m],((e,r)=>r.hasOwnProperty(a)?r[a]:e)).on(p,((e,r)=>r))}function c(r){const{filter:i,domain:o,fields:n,validateOn:s,units:c}=r,v={},f=[],m=[];for(const e in n){if(!n.hasOwnProperty(e))continue;const r=u(e,n[e],o);v[e]=r,f.push(r.$isDirty),m.push(r.$touched)}const h=function(r){const i={};for(const e in r)r.hasOwnProperty(e)&&(i[e]=r[e].$value);return e(i)}(v),$=function(r){const i=[];for(const e in r){if(!r.hasOwnProperty(e))continue;const{$firstError:t}=r[e];i.push(t)}return e(i).map((e=>e.every((e=>null===e))))}(v),g=i?e($,i,((e,r)=>e&&r)):$,p=e(f).map((e=>e.some(Boolean))),x=e(m).map((e=>e.some(Boolean))),V=e({isValid:$,isDirty:p,touched:x}),E=l.event({domain:o,existing:null==c?void 0:c.validate}),y=l.event({domain:o,existing:null==c?void 0:c.submit}),T=l.event({domain:o,existing:null==c?void 0:c.formValidated}),b=l.event({domain:o,existing:null==c?void 0:c.setInitialForm}),F=l.event({domain:o,existing:null==c?void 0:c.setForm}),k=l.event({domain:o,existing:null==c?void 0:c.addErrors}),O=l.event({domain:o,existing:null==c?void 0:c.reset}),S=l.event({domain:o,existing:null==c?void 0:c.resetValues}),w=l.event({domain:o,existing:null==c?void 0:c.resetErrors}),D=l.event({domain:o,existing:null==c?void 0:c.resetTouched}),B=t({source:h,clock:y}),C=t({source:h,clock:E});for(const e in v){if(!v.hasOwnProperty(e))continue;const r=n[e],i=v[e];d({form:{setForm:F,setInitialForm:b,resetForm:O,resetTouched:D,resetValues:S},field:i}),a({form:{$values:h,submit:y,reset:O,addErrors:k,resetValues:S,resetErrors:w,validate:E,validateOn:s},fieldConfig:r,field:i})}t({source:B,filter:g,target:T}),t({source:C,filter:g,target:T});const P={isValid:$,isDirty:p,touched:x,submit:y,reset:O,addErrors:k,validate:E,setForm:F,setInitialForm:b,resetTouched:D,resetValues:S,resetErrors:w,formValidated:T};return{fields:v,$values:h,$eachValid:$,$isValid:$,$isDirty:p,$touched:x,$meta:V,submit:y,validate:E,resetTouched:D,addErrors:k,reset:O,resetValues:S,resetErrors:w,setForm:F,setInitialForm:b,set:F,formValidated:T,"@@unitShape":()=>P}}function v(e,r){const i=null!=r&&r.length?r:Object.keys(e.fields),t={},o={};i.forEach((r=>{o[r]=n(e.fields[r]),t[r]=s(e.fields[r].$value)}));const l=n(e.submit);return{models:t,fields:o,submit:l}}function f(e,r){const i=e.models[r];return{modelValue:i.value,"onUpdate:modelValue":e=>{i.value=e},name:r,fields:e.fields}}export{c as createForm,f as makeInputBinder,v as useForm};
